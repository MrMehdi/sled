#!/bin/sh

# kslink, the only 'linker' stupid enough to link C programs together by concatenating them

GFX_FUNCS="init deinit reset draw"
OUT_FUNCS="init deinit set get clear render getx gety wait_until wait_until_break"
MOD_FUNCS="init deinit setdir load loaddir"
ALL_FUNCS="init deinit reset draw set get clear render getx gety wait_until wait_until_break setdir load loaddir"

RVL=""
for x in "$@"; do
 name=`echo $x | grep -o [^/]*\.c$ | grep -o ^[^\.]*`
 RVL="$name $RVL"
 # repeated later
 FUNCS=$GFX_FUNCS
 echo $name | grep "^out_" >/dev/null 2>/dev/null && FUNCS=$OUT_FUNCS
 echo $name | grep "^flt_" >/dev/null 2>/dev/null && FUNCS=$OUT_FUNCS
 echo $name | grep "^mod_" >/dev/null 2>/dev/null && FUNCS=$MOD_FUNCS
 # --
 # File to write this wrapper to
 FN="modwraps/$name.c"
 FNLD="modwraps/$name.incs"
 FNLS="../src/modules/$name.incs"
 rm -f $FNLD
 cp $FNLS $FNLD 2>/dev/null
 echo "// Autogenerated function wrapper" > $FN
 # The defines/undefines are shared between both the modwrap and main,
 # since we need to use plugin.h for the prototypes
 for y in $FUNCS; do
  echo "#define $y kslink_"$name"_"$y >> $FN
 done
 for y in $ALL_FUNCS; do
  echo "#define $y kslink_"$name"_"$y
 done
 echo "#include \"$x\"" >> $FN
 echo "#include <plugin.h>"
 for y in $FUNCS; do
  echo "#undef $y" >> $FN
 done
 for y in $ALL_FUNCS; do
  echo "#undef $y"
 done
done
echo "#include <loadcore.h>"
echo "#include <assert.h>"
echo "#include <stdlib.h>"
echo "#include <string.h>"
echo "typedef struct kslink_module {"
for y in $ALL_FUNCS; do
 echo "	void * $y;"
done
echo "} kslink_module;"
for name in $RVL; do
 echo "static kslink_module kslink_"$name"_MOD = {"
 # this is repeated from the previous
 FUNCS=$GFX_FUNCS
 echo $name | grep "^out_" >/dev/null 2>/dev/null && FUNCS=$OUT_FUNCS
 echo $name | grep "^flt_" >/dev/null 2>/dev/null && FUNCS=$OUT_FUNCS
 echo $name | grep "^mod_" >/dev/null 2>/dev/null && FUNCS=$MOD_FUNCS
 for y in $FUNCS; do
  echo " .$y = &kslink_"$name"_$y,"
 done
 # --
 echo "};"
done
echo "void loadcore_setdir(const char * str) {"
echo " // And today I just don't care about any of this, tralala lalala"
echo " // I just want to ignore this setdir, tralala lalala"
echo " // Don't feel like setting a directory"
echo " // Just ignore the value at the tone"
echo " // 'cause today I don't feel like doing a setdir, no setdir at all"
echo "}"
echo "char ** loadcore_init(int * argc) {"
echo "	char ** basis = malloc(sizeof(char*) * `echo $RVL | wc -w`);"
echo "	assert(basis);"
RVLI=0
for name in $RVL; do
 echo "	assert((basis[$RVLI] = strdup(\"$name\")));"
 RVLI=`expr $RVLI + 1`
done
echo "	*argc = $RVLI;"
echo "	return basis;"
echo "}"
echo "void * loadcore_open(const char * str) {"
for name in $RVL; do
 echo "	if (!strcmp(str, \""$name"\"))"
 echo "		return &kslink_"$name"_MOD;"
done
echo "	return NULL;"
echo "}"
echo "void * loadcore_sym(void * targ, const char * str) {"
echo "	kslink_module * mstar = (kslink_module *) targ;"
for y in $ALL_FUNCS; do
 echo "	if (!strcmp(str, \"$y\"))"
 echo "		return mstar->$y;"
done
echo "	return NULL;"
echo "}"
echo "char * loadcore_error() {"
echo "	return 0;"
echo "}"
echo "void loadcore_close(void * targ) {"
echo "}"
